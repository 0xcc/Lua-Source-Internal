Lua中的数据类型
=====================
在Lua中,分为以下几种数据类型:
        
    #define LUA_TNONE (-1)
    
    #define LUA_TNIL 0
    #define LUA_TBOOLEAN 1
    #define LUA_TLIGHTUSERDATA 2
    #define LUA_TNUMBER 3
    #define LUA_TSTRING 4
    #define LUA_TTABLE 5
    #define LUA_TFUNCTION 6
    #define LUA_TUSERDATA 7
    #define LUA_TTHREAD 8


其中的LUA_TLIGHTUSERDATA和LUA_TUSERDATA一样,对应的都是void*指针,区别在于,LUA_TLIGHTUSERDATA的分配释放是由Lua外部的使用者来完成,而LUA_TUSERDATA则是通过Lua内部来完成的,换言之,前者不需要Lua去关心它的生存期,由使用者自己去关注,后者则反之.

Lua内部用一个宏,表示哪些数据类型需要进行gc操作的:

    #define iscollectable(o) (ttype(o) >= LUA_TSTRING)


可以看到,LUA_TSTRING(包括LUA_TSTRING)之后的数据类型,都需要进行gc操作.

那么,对于这些需要进行gc操作的数据类型,在Lua中是如何表示的呢?

这些需要gc的数据类型,都会有一个CommonHeader的成员,并且这个成员在结构体定义的最开始部分,如:

    typedef struct Table {
      CommonHeader;
      lu_byte flags;  /* 1<<p means tagmethod(p) is not present */ 
      lu_byte lsizenode;  /* log2 of size of `node' array */
      struct Table *metatable;
      TValue *array;  /* array part */
      Node *node;
      Node *lastfree;  /* any free position is before this position */
      GCObject *gclist;
      int sizearray;  /* size of `array' array */
    } Table;

其中CommonHeader的定义如下:

    /*
    ** Common Header for all collectable objects (in macro form, to be
    ** included in other objects)
    */
    #define CommonHeader GCObject *next; lu_byte tt; lu_byte marked

同时,还有一个名为GCheader的结构体,其中的成员只有CommonHeader:

    /*
    ** Common header in struct form
    */
    typedef struct GCheader {
      CommonHeader;
    } GCheader;

于是,在Lua中就使用了一个GCObject的union将所有可gc类型囊括了进来:

    union GCObject {
      GCheader gch;
      union TString ts;
      union Udata u;
      union Closure cl;
      struct Table h;
      struct Proto p;
      struct UpVal uv;
      struct lua_State th;  /* thread */
    };


我们整理一下前面提到的这么几个结构体,可以得到这样的结论:
>1) 任何需要gc的Lua数据类型,必然以CommonHeader做为该结构体定义的最开始部分.如果熟悉C++类实现原理的人,可以将CommonHeader这个成员理解为一个基类的所有成员,而其他需要gc的数据类型均从这个基类中继承下来,所以它们的结构体定义开始部分都是这个成员.
>
>
>2) GCObject这个union,将所有需要gc的数据类型全部囊括其中,这样在定位和查找不同类型的数据时就来的方便多了,而如果只想要它们的GC部分,可以通过GCheader gch,如:
>
    #define gcvalue(o)  check_exp(iscollectable(o), (o)->value.gc) 


仅表示了需要gc的数据类型还不够,还有几种数据类型是不需要gc的,Lua中将GCObject和它们一起放在了union Value中:

    /*
    ** Union of all Lua values
    */
    typedef union {
      GCObject *gc;
      void *p;
      lua_Number n;
      int b;
    } Value;

到了这一步,已经差不多可以表示所有在Lua中存在的数据类型了,但是还欠缺一点东西,就是这些数据到底是什么类型的.于是Lua代码中又有了一个TValuefields将Value和类型结合在一起:

    #define TValuefields Value value; int tt

这些合在一起,最后形成了Lua中的TValue结构体,在Lua中的任何数据都可以通过该结构体进行表示:

    typedef struct lua_TValue {
      TValuefields;
    } TValue;

![Tvalue](https://github.com/lichuang/Lua-Source-Internal/blob/master/pic/gcobject.png "TValue")