###协程
####概念介绍

####相关的API
#####luaB_cocreate
	(lbaselib.c)
	576 static int luaB_cocreate (lua_State *L) {
	577   lua_State *NL = lua_newthread(L);
	578   luaL_argcheck(L, lua_isfunction(L, 1) && !lua_iscfunction(L, 1), 1,
	579     "Lua function expected");
	580   lua_pushvalue(L, 1);  /* move function to top */
	581   lua_xmove(L, NL, 1);  /* move function from L to NL */
	582   return 1;
	583 }
	
可以看到,这里主要做几件事情:

	1. 调用lua_newthread创建lua_State结构体.
	2. 坚持当前栈顶的元素是不是一个函数对象,因为需要一个函数做为协程开始运行时的主函数.
	3. 将协程主函数压入当前lua_State中的栈中,然后调用lua_xmove将该函数从当前的lua_State移动到新创建的协程的lua_State栈中.

####luaB_coresume
	(lbaselib.c)
	543 static int luaB_coresume (lua_State *L) {
	544   lua_State *co = lua_tothread(L, 1);
	545   int r;
	546   luaL_argcheck(L, co, 1, "coroutine expected");
	547   r = auxresume(L, co, lua_gettop(L) - 1);
	548   if (r < 0) {
	549     lua_pushboolean(L, 0);
	550     lua_insert(L, -2);
	551     return 2;  /* return false + error message */
	552   }
	553   else {
	554     lua_pushboolean(L, 1);
	555     lua_insert(L, -(r + 1));
	556     return r + 1;  /* return true + `resume' returns */
	557   }
	558 }
	
可以看到,这里主要做几件事情:

	1. 检查当前栈顶元素是不是协程指针.
	2. 调用辅助函数auxresume进行实际的resume操作.
	3. 根据auxresume的返回值来做不同的处理.当返回值小于0时,说明resume操作出错,并且此时出错信息在栈顶,因此压入"false"以及出错消息;否则,auxresume的返回值表示执行resume时返回的参数数量,这种情况下压入"true"以及这些返回参数.

auxresume函数中最终会调用resume函数来执行实际的resume操作:

	(ldo.c)
	383 static void resume (lua_State *L, void *ud) {
	384   StkId firstArg = cast(StkId, ud);
	385   CallInfo *ci = L->ci;
	386   if (L->status == 0) {  /* start coroutine? */
	387     lua_assert(ci == L->base_ci && firstArg > L->base);
	388     if (luaD_precall(L, firstArg - 1, LUA_MULTRET) != PCRLUA)
	389       return;
	390   }
	391   else {  /* resuming from previous yield */
	392     lua_assert(L->status == LUA_YIELD);
	393     L->status = 0;
	394     if (!f_isLua(ci)) {  /* `common' yield? */
	395       /* finish interrupted execution of `OP_CALL' */
	396       lua_assert(GET_OPCODE(*((ci-1)->savedpc - 1)) == OP_CALL ||
	397                  GET_OPCODE(*((ci-1)->savedpc - 1)) == OP_TAILCALL);
	398       if (luaD_poscall(L, firstArg))  /* complete it... */
	399         L->top = L->ci->top;  /* and correct top if not multiple results */
	400     }
	401     else  /* yielded inside a hook: just continue its execution */
	402       L->base = L->ci->base;
	403   }
	404   luaV_execute(L, cast_int(L->ci - L->base_ci));
	405 }
	
这个函数做了以下的事情:

	1.如果当前协程的状态是0,那么说明它是第一次执行resume操作,此时调用luaD_precall做函数调用前的准备工作. luaD_precall函数如果返回值不是PCRLUA,说明是在C函数中进行resume操作的,此时并不需要后面的luaV_execute函数,因此就直接返回了.
	2.否则就是从之前的YIELD状态中继续执行,首先将协程的状态置为0,其次判断此时ci的类型,如果不是Lua函数,说明之前是被中断的函数调用,此时调用luaD_poscall函数继续完成未完的函数操作;否则只需要调整base指针即可.
	3.以上的几种情况,最终都会调用luaV_execute函数来进入Lua虚拟机中执行.
	
####yield

	(ldo.c)
	443 LUA_API int lua_yield (lua_State *L, int nresults) {
	444   luai_userstateyield(L, nresults);
	445   lua_lock(L);
	446   if (L->nCcalls > L->baseCcalls)
	447     luaG_runerror(L, "attempt to yield across metamethod/C-call boundary");
	448   L->base = L->top - nresults;  /* protect stack slots below */
	449   L->status = LUA_YIELD;
	450   lua_unlock(L);
	451   return -1;
	452 }
	


	
	
	
	








 
	





