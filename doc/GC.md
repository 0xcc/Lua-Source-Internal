##Lua GC

###原理
一个GC算法,其原理大体就是,遍历系统中的所有对象,看哪些对象没有被引用,没有引用关系的就认为是可以回收的对象进行删除操作.

这里的关键在于,如何找出没有"引用"的对象.

使用引用计数的GC算法,会在一个对象被引用的情况下将该对象的引用计数加1;反之减1.如果引用计数为0,那么就是没有被引用的对象.

另一种算法是"Mark & Sweep",标记及回收算法.

另一种算法是"Two-Color Mark & Sweep",两色标记及回收算法,其算法的原理是,系统中的每个对象非黑即白,也就是要么被引用要么没有被引用.我们来简单看看这个算法的伪代码:

	每个新创建的对象颜色为白色

	// 初始化阶段
	遍历在root链表中的对象,加入到对象链表

	// 标记阶段
	当对象链表中还有未扫描的元素:
		从中取出一个对象,标记为黑色
		遍历这个对象关联的其他所有对象:
			标记为黑色

	// 回收阶段
	遍历所有对象:
		如果为白色:
			这些对象都是没有被引用的对象,逐个回收
		否则:
			重新加入对象链表中等待下一轮的GC检查

Lua5.0就是使用的这个算法.这个算法的缺陷在于,如前面所言,它是"二元"的,每个对象只可能有一种状态,不能有其他中间的状态,那么就要求这个算法每次做GC操作时不可被打断的一次性扫描并清除完毕所有的对象.

来看看这个过程不能被打断的原因.在遍历对象链表标记每个对象颜色的过程中被打断,新增了一个对象,那么应该将这个对象标记为白色还是黑色?如果标记为白色,假如GC已经到了回收阶段,那么这个对象就会在没有遍历其关联对象的情况下被回收;如果标记为黑色,假如GC已经到了回收阶段,那么这个对象在本轮GC中并没有被扫描过就认为是不必回收的.可以看到,在双色标记扫描算法中,标记阶段和回收阶段必须合在一起完成.不能被打断,也就意味着每次GC操作的代价极大.

Lua5.1采用了在该算法基础上改进的"Tri-Color Incremental Mark & Sweep",三色增量标记及回收算法,比之前面而言,每个对象的颜色多了一种(实际在Lua中是四种,后面展开讨论),多了一种颜色状态的好处在于,它不必再要求一次GC要一次性扫描完毕所有的对象,而是这个GC过程可以是增量,可以被中断再恢复继续进行的.同样需要注意到,前面两种算法的命名,除了颜色数上的差异,后者还多了单词"Incremental",这才是这个算法真正的目的.

	每个新创建的对象颜色为白色

	// 初始化阶段
	遍历在root链表中的对象,加入到灰色链表

	// 标记阶段
	当灰色链表中还有未扫描的元素:
		从中取出一个对象,标记为黑色
		遍历这个对象关联的其他所有对象:
			如果是白色:
				标记为灰色,加入灰色链表

	// 回收阶段
	遍历所有对象:
		如果为白色:
			这些对象都是没有被引用的对象,逐个回收
		否则:
			重新加入对象链表中等待下一轮的GC检查

在这里,同前面一样,白色代表没有被引用的对象,黑色代表已经被扫描过并且其引用的对象也被扫描过的对象,而多出来的灰色表示的是已经被扫描但是其引用的对象还没有被扫描的对象.

我们来看看多了一种颜色具体带来了什么好处.


来看看三色标记扫描算法中的改进.同样是前面的

###算法


 
	





